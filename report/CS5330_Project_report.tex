\documentclass[]{report}   
\usepackage{tabto}
\usepackage{amsmath}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\usepackage{bm}
\newtheorem{definition}{Definition}

\setlength{\parindent}{4em}



\begin{document}

\title{CS5330 Implementation Project 1}   
\author{Reinaldo Maslim - \\
Vicknesh S/O Jegathesan - A0113973A\\\
Xu Yunze -}
\date{April 26, 2020}   
\maketitle


\maketitle                              
                 
\tableofcontents 



            
\chapter{Introduction}                

The purpose of this implementation project is to test variations of the count sketch implementation for summarizing data streams. Using the Count-Min Sketch data structure, we analyse the query, insert and delete operations performed on the data streams. The goal would be to optimize the time and space needed for the operations on the data structure.\\

Count Min Sketch was first implemented to summarise large amounts of data streams via a high dimensional vector and perform operations on this data structure. These operations can be used to answer a variety of queries such as heavy hitters, quantile estimation and joint size estimation. The structure has an efficient update and delete process which makes it highly suitable for data streams.\\

%Reinaldo - Describe the problem statement and what we are analysing%



\chapter{Preliminaries}                

The data structure itself is a 2 dimensional array with width w and depth d. Given the parameters $\epsilon and \delta$ we choose the width and depth. The d hash functions chosen are 2 universal.\\


\begin{definition}
H is a 2-universal if for all $x, y \in U$ such that $x \neq y$ we have\\

$Pr_{h - H} (h(x) = h(y)) \leq \frac{1}{n}$\\

where $h - H$ means that h is selected uniformly at random from H.\\
\end{definition}


When an update arrives $(i_t, c_t)$, then $c_t$ is added to one entry in each row of the array count. In other words, for $1 \leq j \leq d\ $ $count[j, h_j(i_t)] <- count[s, j, h_j(i_t)] + c_t$.\\

In our report $\tilde{f}$ is the frequency vector and it is given by $f_j = \sum_{i: x_i = j}c_i$\\

The types of queries that can be answered by the count min sketch data structure is given below. Consider a vector $[x_ 1, \hdots, x_n]$\\

Point Queries: Given a i, return an approximation for $x_i$.\\

Range Query: Given l,r, return an approximation of $\sum_{i=l}^{r} x_i$\\

Heavy Hitters Query: Given $\phi \in (0,1)$. a heavy hitter is given by $x_i \geq \phi||x||$. We return all the approximate heavy hitters i such that $x_i \geq (\phi - \epsilon)||x||$.\\


Quantile Query: Given $\phi \in (0,1)$, return j such that $ (\phi - \epsilon)||x|| \leq \sum_{i=1}^{j}x_j \leq (\phi + \epsilon)||x||$


\chapter{Algorithm Description}                

Here we will introduce the pseudo code for the algorithms used in the analysis.\\

\section{Count Min Sketch}   




\ \ \ \ \ \ \ \ \ \ \ \ 1: Initialize\\

2: k $<-\ \ceil*{\frac{2}{\epsilon}}$\\

3: t $<-\ \floor*{\log_2(\frac{1}{\delta})}$\\

4: c $<-$ t x k integer array, with all entries initiated to 0\\

5: Choose $h_1, \hdots, h_t: [M] -> [k]$ independently from a 2\\

\ \ \ \ universal family of hash functions.\\

6: \\

\ \ \ \ for each i do\\

\ \ \ \ \ \ \ \ for s = 1 to t do\\
	
\ \ \ \ \ \ \ \ \ \ \ \ $C[s, h(x_i)] <- C[s, h(x_i)] + c_i$\\
		
\ \ \ \ \ \ \ \ end for\\
	
\ \ \ \ end for\\

Output: $ \tilde{f} <- (C, h_1 \hdots, h_t)$\\

$\tilde{f}_j = min{C[s, h_s(j)] : s = 1 \hdots t}$\\



 


\section{Count Median Sketch}   


%Reinaldo - Pseudo code for 2nd algorithm%

\chapter{Implementation}                

%Xu Yunze Results and Memory management%


\chapter{Conclusions}                

      
%We can all fill in this together%


\begin{thebibliography}{9}
  % type bibliography here
\end{thebibliography}

\end{document}